<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Sulphur Run - Mobile Edition</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="mobile-web-app-capable" content="yes">
    
    <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=VT323&display=swap">

    <style>
        body {
            margin: 0;
            padding: 0;
            background-color: #050505;
            color: #eee;
            font-family: 'VT323', monospace;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100vh;
            width: 100vw;
            overflow: hidden;
            touch-action: none; /* Prevents scrolling on mobile */
        }

        #game-wrapper {
            position: relative;
            width: 100%;
            height: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        #game-container {
            position: relative;
            width: 1000px;
            height: 500px;
            border: 2px solid #444;
            box-shadow: 0 0 10px #d4a24e;
            background-color: #08060a; 
            image-rendering: pixelated;
            user-select: none; 
            -webkit-user-select: none;
        }

        /* MOBILE PORTRAIT TRANSFORMATION */
        @media (orientation: portrait) {
            #game-container {
                /* Rotate 90 degrees to fit portrait phone */
                transform: rotate(90deg);
                /* Scale to fit width of phone height */
                width: 100vh; 
                height: 50vh; /* Aspect ratio maintenance */
                max-width: 90vh; /* Safety margin */
                max-height: 45vh;
            }
            /* Adjust controls hint for mobile */
            .controls-hint { font-size: 1.5rem !important; }
            .tip-small { font-size: 1.2rem !important; }
        }

        /* MOBILE LANDSCAPE / DESKTOP */
        @media (orientation: landscape) {
            #game-container {
                transform: none;
                max-width: 95vw;
                max-height: 95vh;
                /* Maintain aspect ratio */
                width: 1000px;
                height: 500px;
            }
            /* Responsive scaling for smaller landscape screens */
            @media (max-width: 1000px) {
                #game-container {
                    width: 90vw;
                    height: 45vw;
                }
            }
        }

        canvas {
            display: block;
            width: 100%;
            height: 100%;
        }

        .ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            background: radial-gradient(circle, rgba(0,0,0,0.3) 0%, rgba(0,0,0,0.7) 100%);
        }

        #start-screen, #game-over-screen, #pause-screen {
            background: rgba(10, 5, 5, 0.9);
            padding: 20px; 
            border: 2px solid #d4a24e;
            text-align: center;
            pointer-events: auto;
            /* Counter-rotate text on mobile so it's readable upright? 
               No, we want the player to turn the phone sideways physically 
               even if the app is portrait. But user asked for portrait app. 
               We will keep UI inside the game container so it rotates WITH the game. */
        }

        h1 { font-size: 3rem; margin: 0; color: #fff; text-shadow: 2px 2px 0 #444; }
        p { font-size: 1.5rem; color: #ccc; margin: 10px 0; }
        .blink { animation: blinker 1s infinite; color: #fff; }
        @keyframes blinker { 50% { opacity: 0; } }

        .hud {
            position: absolute;
            top: 10px; left: 10px;
            font-size: 1.5rem;
            color: #d4a24e;
            background: rgba(0,0,0,0.5);
            padding: 5px 10px;
            border-left: 3px solid #d4a24e;
            display: none;
        }

        .controls-hint { margin-top: 20px; font-size: 1rem; color: #888; border-top: 1px solid #444; padding-top: 10px; }
    </style>
</head>
<body>

    <div id="game-wrapper">
        <div id="game-container">
            <canvas id="gameCanvas" width="1000" height="500"></canvas>
            
            <div class="hud" id="hud">
                DIST: <span id="score-dist">0</span> <span style="color:#555">|</span> 
                DATA: <span id="score-data" style="color:#fff">0</span> <span style="color:#555">|</span> 
                PHASE: <span id="score-phase" style="color: #61dafb">Î±</span>
            </div>

            <div class="ui-layer" id="start-screen">
                <h1 id="title-text">SULPHUR RUN</h1>
                <p>MOBILE EDITION</p>
                <p class="blink">[TAP TO START]</p>
                <div class="controls-hint">
                    RIGHT SIDE (Top): JUMP<br>
                    LEFT SIDE (Bottom): SHOOT
                </div>
            </div>

            <div class="ui-layer" id="game-over-screen" style="display: none;">
                <h1>CRITICAL FAILURE</h1>
                <p style="color:#ff4444;">SRV DESTROYED</p>
                <p>SCORE: <span id="final-data">0</span></p>
                <p class="blink">[TAP TO REBOOT]</p>
            </div>
        </div>
    </div>

<script>
/** SULPHUR RUN ENGINE (MOBILE OPTIMIZED) */

const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');

// --- AUDIO SYSTEM ---
// We use a simplified synth for mobile performance and to avoid loading MP3s 
const AudioContext = window.AudioContext || window.webkitAudioContext;
let actx = new AudioContext();

function resumeAudio() {
    if (actx.state === 'suspended') {
        actx.resume();
    }
}

function playSound(type) {
    if (actx.state === 'suspended') return;
    const osc = actx.createOscillator();
    const gain = actx.createGain();
    const now = actx.currentTime;
    
    osc.connect(gain);
    gain.connect(actx.destination);

    if (type === 'jump') {
        osc.frequency.setValueAtTime(150, now);
        osc.frequency.exponentialRampToValueAtTime(300, now + 0.1);
        gain.gain.setValueAtTime(0.1, now);
        gain.gain.exponentialRampToValueAtTime(0.01, now + 0.2);
        osc.start(now); osc.stop(now + 0.2);
    } else if (type === 'shoot') {
        osc.type = 'square';
        osc.frequency.setValueAtTime(400, now);
        osc.frequency.exponentialRampToValueAtTime(100, now + 0.1);
        gain.gain.setValueAtTime(0.1, now);
        gain.gain.exponentialRampToValueAtTime(0.01, now + 0.1);
        osc.start(now); osc.stop(now + 0.1);
    } else if (type === 'collect') {
        osc.type = 'sine';
        osc.frequency.setValueAtTime(800, now);
        osc.frequency.linearRampToValueAtTime(1200, now + 0.1);
        gain.gain.setValueAtTime(0.1, now);
        gain.gain.linearRampToValueAtTime(0.01, now + 0.15);
        osc.start(now); osc.stop(now + 0.15);
    } else if (type === 'hit') {
        osc.type = 'sawtooth';
        osc.frequency.setValueAtTime(100, now);
        gain.gain.setValueAtTime(0.2, now);
        gain.gain.exponentialRampToValueAtTime(0.01, now + 0.3);
        osc.start(now); osc.stop(now + 0.3);
    }
}

// --- GAME CONFIG ---
let gameState = 'START';
let frames = 0;
let gameSpeed = 6;
let scoreDist = 0;
let scoreData = 0;
const GRAVITY = 0.5; // Slightly higher gravity for snappier mobile feel
const GROUND_Y = 400;

// --- ENTITIES ---
const rover = {
    x: 100, y: GROUND_Y, width: 40, height: 20, dy: 0, grounded: true, jumps: 0,
    draw: function() {
        ctx.save();
        ctx.translate(this.x + 20, this.y + 10);
        // Chassis
        ctx.fillStyle = '#d4a24e';
        ctx.fillRect(-20, -10, 40, 16);
        // Cockpit
        ctx.fillStyle = '#61dafb';
        ctx.fillRect(0, -14, 15, 8);
        // Wheels
        ctx.fillStyle = '#222';
        ctx.beginPath(); ctx.arc(-15, 8, 7, 0, Math.PI*2); ctx.fill();
        ctx.beginPath(); ctx.arc(15, 8, 7, 0, Math.PI*2); ctx.fill();
        ctx.restore();
    },
    update: function() {
        this.dy += GRAVITY;
        this.y += this.dy;
        if (this.y > GROUND_Y - 10) {
            this.y = GROUND_Y - 10;
            this.dy = 0;
            this.grounded = true;
            this.jumps = 0;
        } else {
            this.grounded = false;
        }
    },
    jump: function() {
        if (this.jumps < 2) {
            this.dy = -10;
            this.jumps++;
            this.grounded = false;
            playSound('jump');
        }
    },
    shoot: function() {
        projectiles.push({x: this.x + 40, y: this.y + 5, vx: 15, life: 60});
        playSound('shoot');
    }
};

let obstacles = [];
let projectiles = [];
let particles = [];
let stars = [];

function initStars() {
    stars = [];
    for(let i=0; i<50; i++) {
        stars.push({x: Math.random()*1000, y: Math.random()*400, s: Math.random()*2});
    }
}

function startGame() {
    resumeAudio(); // Important for mobile!
    gameState = 'PLAYING';
    document.getElementById('start-screen').style.display = 'none';
    document.getElementById('game-over-screen').style.display = 'none';
    document.getElementById('hud').style.display = 'block';
    scoreData = 0;
    gameSpeed = 6;
    obstacles = [];
    projectiles = [];
    initStars();
}

function spawnObstacle() {
    const type = Math.random() > 0.5 ? 'ROCK' : 'SPIKE';
    obstacles.push({x: 1050, y: GROUND_Y, w: 30, h: 30, type: type, hp: 1});
}

// --- LOOP ---
function loop() {
    requestAnimationFrame(loop);
    
    // Background
    ctx.fillStyle = '#0a0a15';
    ctx.fillRect(0, 0, 1000, 500);
    
    // Stars
    ctx.fillStyle = '#fff';
    stars.forEach(s => {
        s.x -= gameSpeed * 0.1;
        if(s.x < 0) s.x = 1000;
        ctx.fillRect(s.x, s.y, s.s, s.s);
    });

    // Ground
    ctx.fillStyle = '#332211';
    ctx.fillRect(0, GROUND_Y+10, 1000, 90);
    ctx.strokeStyle = '#d4a24e';
    ctx.beginPath(); ctx.moveTo(0, GROUND_Y+10); ctx.lineTo(1000, GROUND_Y+10); ctx.stroke();

    if (gameState === 'PLAYING') {
        frames++;
        if (frames % 100 === 0) spawnObstacle();
        
        rover.update();
        rover.draw();
        
        // Projectiles
        ctx.fillStyle = '#ff0';
        for (let i = projectiles.length-1; i>=0; i--) {
            let p = projectiles[i];
            p.x += p.vx;
            p.life--;
            ctx.fillRect(p.x, p.y, 10, 4);
            if(p.life <= 0) projectiles.splice(i,1);
        }

        // Obstacles
        for (let i = obstacles.length-1; i>=0; i--) {
            let o = obstacles[i];
            o.x -= gameSpeed;
            
            // Draw
            ctx.fillStyle = o.type === 'ROCK' ? '#776655' : '#ff4444';
            ctx.fillRect(o.x, GROUND_Y - 20, o.w, 30);

            // Collision - Rover
            if (rover.x < o.x + o.w && rover.x + rover.width > o.x &&
                rover.y < GROUND_Y + 10 && rover.y + rover.height > GROUND_Y - 20) {
                
                playSound('hit');
                gameState = 'GAMEOVER';
                document.getElementById('final-data').innerText = scoreData;
                document.getElementById('game-over-screen').style.display = 'flex';
                document.getElementById('hud').style.display = 'none';
            }

            // Collision - Projectile
            for (let k = projectiles.length-1; k>=0; k--) {
                let p = projectiles[k];
                if (p.x > o.x && p.x < o.x + o.w && p.y > GROUND_Y - 20) {
                    playSound('collect');
                    obstacles.splice(i, 1);
                    projectiles.splice(k, 1);
                    scoreData += 10;
                    document.getElementById('score-data').innerText = scoreData;
                    break; // break projectile loop
                }
            }
            if (o.x < -50 && obstacles[i]) obstacles.splice(i, 1);
        }
    } else {
        rover.draw(); // Draw rover even if paused/gameover
    }
}

// --- INPUTS ---
window.addEventListener('keydown', e => {
    if(e.code === 'Space') { 
        if(gameState==='START' || gameState==='GAMEOVER') startGame();
        else rover.jump();
    }
    if(e.code === 'Enter') rover.shoot();
});

// TOUCH CONTROLS (Portrait logic: Top half Jump, Bottom half Shoot)
window.addEventListener('touchstart', e => {
    e.preventDefault(); // Stop scrolling
    resumeAudio();

    if(gameState === 'START' || gameState === 'GAMEOVER') {
        startGame();
        return;
    }

    const touchY = e.touches[0].clientY;
    const height = window.innerHeight;

    // In portrait mode with rotation, the logic flips visually.
    // If phone is portrait, we are rotated 90deg.
    // The "Right" of the game is the Top of the phone.
    // The "Left" of the game is the Bottom of the phone.
    
    // Simple logic:
    // Tap Top of Phone = Jump
    // Tap Bottom of Phone = Shoot
    
    if (touchY < height / 2) {
        rover.jump(); // Top half
    } else {
        rover.shoot(); // Bottom half
    }
}, {passive: false});

initStars();
loop();

</script>
</body>
</html>
