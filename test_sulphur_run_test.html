<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Sulphur Run: Portrait</title>
    <!-- Critical for mobile: prevent zooming and scrolling -->
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="mobile-web-app-capable" content="yes">
    
    <!-- Fonts -->
    <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=VT323&display=swap">

    <style>
        body {
            margin: 0;
            padding: 0;
            background-color: #050505;
            color: #eee;
            font-family: 'VT323', monospace;
            height: 100vh;
            width: 100vw;
            overflow: hidden;
            touch-action: none; /* Stops pull-to-refresh on mobile */
            user-select: none;
            -webkit-user-select: none;
        }

        #game-container {
            position: relative;
            width: 100%;
            height: 100%;
            background-color: #08060a; 
            image-rendering: pixelated;
        }

        canvas {
            display: block;
            width: 100%;
            height: 100%;
        }

        /* UI OVERLAYS */
        .ui-layer {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            background: rgba(0,0,0,0.7);
            z-index: 20;
            pointer-events: auto; /* Ensure clicks register here */
            cursor: pointer;
        }

        .hidden {
            display: none !important;
            pointer-events: none;
        }

        h1 {
            color: #d4a24e;
            font-size: 3.5rem;
            margin: 0 0 10px 0;
            text-shadow: 3px 3px 0px #222;
            line-height: 0.9;
            text-align: center;
        }

        p { font-size: 1.4rem; color: #ccc; margin: 5px 0; text-align: center; }
        
        .blink { animation: blinker 1s infinite; color: #fff; margin-top: 25px; font-size: 1.6rem; }
        @keyframes blinker { 50% { opacity: 0; } }

        /* HUD */
        .hud {
            position: absolute;
            top: 15px; left: 15px; right: 15px;
            display: flex;
            justify-content: space-between;
            font-size: 1.6rem;
            color: #d4a24e;
            text-shadow: 1px 1px 0 #000;
            z-index: 10;
            pointer-events: none;
        }

        /* SPLIT LINE */
        .split-line {
            position: absolute;
            top: 55%;
            left: 5%; width: 90%; height: 1px;
            background: rgba(255,255,255,0.15);
            pointer-events: none;
            z-index: 5;
            border-top: 1px dashed rgba(255,255,255,0.3);
        }

        .controls-hint {
            margin-top: 20px;
            padding: 15px;
            border: 1px solid #444;
            background: rgba(0,0,0,0.5);
            text-align: center;
        }
    </style>
</head>
<body>

<div id="game-container">
    <canvas id="gameCanvas"></canvas>

    <!-- Heads Up Display -->
    <div class="hud" id="hud" style="display:none;">
        <span>DIST: <span id="score-dist" style="color:#fff">0</span>m</span>
        <span>DATA: <span id="score-data" style="color:#61dafb">0</span></span>
    </div>
    
    <!-- Visual Divider for Controls -->
    <div class="split-line" id="split-line" style="display:none;"></div>

    <!-- START SCREEN -->
    <!-- We add onclick directly here to guarantee it fires -->
    <div class="ui-layer" id="start-screen" onclick="triggerStart()">
        <h1>SULPHUR<br>RUN</h1>
        <p style="color:#61dafb; letter-spacing: 2px;">PORTRAIT MODE</p>
        
        <div class="controls-hint">
            <p style="color:#d4a24e">TAP TOP = JUMP</p>
            <p style="color:#ff4444">TAP BOTTOM = SHOOT</p>
        </div>
        
        <p class="blink">[ TAP SCREEN TO START ]</p>
    </div>

    <!-- GAME OVER SCREEN -->
    <div class="ui-layer hidden" id="game-over-screen" onclick="triggerStart()">
        <h1 style="color:#ff4444;">CRITICAL<br>FAILURE</h1>
        <p>DISTANCE: <span id="final-dist">0</span>m</p>
        <p>DATA: <span id="final-data" style="color:#61dafb">0</span></p>
        <p class="blink">[ TAP TO REBOOT ]</p>
    </div>
</div>

<audio id="bgm" loop preload="auto" src="nahla_theme.mp3"></audio>

<script>
/** * SULPHUR RUN - PORTRAIT CANVAS EDITION
 * Corrected Physics, Graphics, and Collision logic.
 */

const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
const bgm = document.getElementById('bgm');

// --- GAME VARIABLES (Declared first to avoid ReferenceError) ---
let gameState = 'START';
let frames = 0;
let gameSpeed = 6;
let scoreDist = 0;
let scoreData = 0;

// Original Physics Constants
const GRAVITY = 0.25; 
const JUMP_FORCE = -8.5; 

// Entity Arrays
let obstacles = [];
let samples = []; 
let projectiles = [];
let particles = [];
let stars = [];

// --- RESIZE HANDLING ---
let SCREEN_W = window.innerWidth;
let SCREEN_H = window.innerHeight;
let GROUND_Y = SCREEN_H * 0.85;

function resize() {
    SCREEN_W = window.innerWidth;
    SCREEN_H = window.innerHeight;
    canvas.width = SCREEN_W;
    canvas.height = SCREEN_H;
    GROUND_Y = SCREEN_H * 0.85;
    initStars(); // Regenerate stars to fill screen
}
window.addEventListener('resize', resize);


// --- AUDIO SYSTEM ---
const AudioContext = window.AudioContext || window.webkitAudioContext;
const actx = new AudioContext();

function resumeAudio() {
    if (actx.state === 'suspended') actx.resume();
    if (bgm && bgm.paused) {
        bgm.volume = 0.5;
        bgm.play().catch(e => console.log("Audio play failed:", e));
    }
}

function playSound(type) {
    if (actx.state === 'suspended') return;
    const osc = actx.createOscillator();
    const gain = actx.createGain();
    const now = actx.currentTime;
    
    osc.connect(gain);
    gain.connect(actx.destination);

    if (type === 'jump') {
        osc.type = 'sawtooth';
        osc.frequency.setValueAtTime(150, now);
        osc.frequency.exponentialRampToValueAtTime(50, now + 0.2);
        gain.gain.setValueAtTime(0.1, now);
        gain.gain.exponentialRampToValueAtTime(0.01, now + 0.2);
        osc.start(now); osc.stop(now + 0.2);
    } else if (type === 'shoot') {
        osc.type = 'square';
        osc.frequency.setValueAtTime(800, now);
        osc.frequency.exponentialRampToValueAtTime(100, now + 0.1);
        gain.gain.setValueAtTime(0.08, now);
        gain.gain.exponentialRampToValueAtTime(0.01, now + 0.1);
        osc.start(now); osc.stop(now + 0.1);
    } else if (type === 'hit') {
        osc.type = 'sawtooth';
        osc.frequency.setValueAtTime(100, now);
        osc.frequency.linearRampToValueAtTime(20, now + 0.4);
        gain.gain.setValueAtTime(0.2, now);
        gain.gain.exponentialRampToValueAtTime(0.01, now + 0.4);
        osc.start(now); osc.stop(now + 0.4);
    } else if (type === 'collect') {
        osc.type = 'sine';
        osc.frequency.setValueAtTime(600, now);
        osc.frequency.linearRampToValueAtTime(1200, now + 0.1);
        gain.gain.setValueAtTime(0.1, now);
        gain.gain.linearRampToValueAtTime(0, now + 0.15);
        osc.start(now); osc.stop(now + 0.15);
    }
}


// --- ROVER OBJECT ---
const rover = {
    x: 40,
    y: 0,
    width: 40,
    height: 20,
    dy: 0,
    grounded: false,
    jumps: 0,
    maxJumps: 2,
    angle: 0,

    reset: function() {
        this.y = GROUND_Y - 20;
        this.dy = 0;
        this.jumps = 0;
        this.angle = 0;
        this.grounded = true;
    },

    update: function() {
        this.dy += GRAVITY;
        this.y += this.dy;

        if (this.y + this.height/2 >= GROUND_Y) {
            this.y = GROUND_Y - this.height/2;
            this.dy = 0;
            this.grounded = true;
            this.jumps = 0;
            this.angle = 0;
        } else {
            this.grounded = false;
            // Tilt animation
            let targetAngle = Math.min(Math.max(this.dy * 0.05, -0.3), 0.3);
            this.angle += (targetAngle - this.angle) * 0.1;
        }
    },

    jump: function() {
        if (this.grounded || this.jumps < this.maxJumps) {
            this.dy = JUMP_FORCE;
            this.grounded = false;
            this.jumps++;
            playSound('jump');
            createParticleExplosion(this.x, this.y + 15, '#d4a24e', 5);
        }
    },

    shoot: function() {
        // Cooldown mechanism
        if (frames % 15 === 0 || frames % 15 === 1) return; // Simple debounce
        
        projectiles.push({
            x: this.x + 30,
            y: this.y + 5,
            vx: 12,
            life: 60
        });
        playSound('shoot');
    },

    draw: function() {
        ctx.save();
        ctx.translate(this.x + this.width/2, this.y + this.height/2);
        ctx.rotate(this.angle);

        // Headlight
        let beam = ctx.createRadialGradient(80, 0, 0, 80, 0, 100);
        beam.addColorStop(0, 'rgba(255, 255, 255, 0.1)');
        beam.addColorStop(1, 'rgba(255, 255, 255, 0)');
        ctx.fillStyle = beam;
        ctx.beginPath();
        ctx.moveTo(10, -5); ctx.lineTo(150, -40); ctx.lineTo(150, 40); ctx.lineTo(10, 5); ctx.fill();

        // Body
        ctx.fillStyle = '#222';
        ctx.fillRect(-20, -10, 40, 16);
        
        // Cockpit
        ctx.fillStyle = '#d4a24e';
        ctx.shadowColor = '#d4a24e'; ctx.shadowBlur = 10;
        ctx.fillRect(-5, -14, 14, 8);
        ctx.shadowBlur = 0;

        // Wheels
        ctx.fillStyle = '#111';
        const bounce = this.grounded ? Math.sin(frames*0.5)*1 : 0;
        ctx.beginPath(); ctx.arc(-15, 8+bounce, 6, 0, 6.28); ctx.fill(); ctx.stroke();
        ctx.beginPath(); ctx.arc(0, 8-bounce, 6, 0, 6.28); ctx.fill(); ctx.stroke();
        ctx.beginPath(); ctx.arc(15, 8+bounce, 6, 0, 6.28); ctx.fill(); ctx.stroke();

        ctx.restore();
    }
};

// --- SPAWNERS ---
function initStars() {
    stars = [];
    for(let i=0; i<80; i++) {
        stars.push({
            x: Math.random() * SCREEN_W,
            y: Math.random() * (GROUND_Y - 50),
            size: Math.random() * 2,
            speed: Math.random() * 0.5 + 0.1
        });
    }
}

function createParticleExplosion(x, y, color, count) {
    for(let i=0; i<count; i++) {
        particles.push({
            x: x, y: y,
            vx: (Math.random()-0.5)*6,
            vy: (Math.random()-0.5)*6,
            life: 25,
            color: color
        });
    }
}

function spawnObstacle() {
    const r = Math.random();
    let type = r > 0.6 ? 'ROCK' : 'SPIKE';
    obstacles.push({
        x: SCREEN_W + 50,
        y: GROUND_Y,
        w: 30, h: 30,
        type: type
    });
}

function spawnSample() {
    samples.push({
        x: SCREEN_W + 50,
        y: GROUND_Y - 50 - Math.random() * 50, // Floating high enough to jump at
        val: 50,
        rot: 0
    });
}

// --- MAIN UPDATE LOOP ---
function update() {
    frames++;
    gameSpeed += 0.001; 
    scoreDist += 0.1;

    // Stars
    stars.forEach(s => {
        s.x -= s.speed;
        if(s.x < 0) s.x = SCREEN_W;
    });

    rover.update();

    // Spawning logic
    if(frames % 120 === 0 && Math.random() > 0.3) spawnObstacle();
    if(frames % 180 === 0) spawnSample();

    // Projectiles
    for(let i=projectiles.length-1; i>=0; i--) {
        let p = projectiles[i];
        p.x += p.vx;
        p.life--;
        if(p.life <= 0 || p.x > SCREEN_W) projectiles.splice(i,1);
    }

    // Obstacles (Dangerous)
    for(let i=obstacles.length-1; i>=0; i--) {
        let o = obstacles[i];
        o.x -= gameSpeed;

        // Collision: Rover vs Obstacle
        // Simple AABB, slightly forgiving
        if (rover.x + 15 > o.x && 
            rover.x - 15 < o.x + o.w &&
            rover.y + 10 > o.y - o.h + 10) { // +10 to allow grazing top
            
            playSound('hit');
            gameOver();
        }

        // Collision: Projectile vs Obstacle
        let destroyed = false;
        for(let j=projectiles.length-1; j>=0; j--) {
            let p = projectiles[j];
            if(p.x > o.x && p.x < o.x + o.w && p.y > o.y - o.h) {
                // Destroy
                playSound('collect'); // Using collect sound for satisfying 'ding'
                createParticleExplosion(o.x+15, o.y-15, '#d4a24e', 8);
                scoreData += 10;
                projectiles.splice(j,1);
                destroyed = true;
                break;
            }
        }
        
        if (destroyed) {
            obstacles.splice(i,1);
            continue;
        }

        if(o.x < -50 && obstacles[i]) obstacles.splice(i,1);
    }

    // Samples (Collectible - Safe)
    for(let i=samples.length-1; i>=0; i--) {
        let s = samples[i];
        s.x -= gameSpeed;
        s.rot += 0.1;

        // Distance check
        let dx = (rover.x + rover.width/2) - s.x;
        let dy = (rover.y + rover.height/2) - s.y;
        if (Math.sqrt(dx*dx + dy*dy) < 40) {
            playSound('collect');
            scoreData += 100;
            createParticleExplosion(s.x, s.y, '#61dafb', 6);
            samples.splice(i,1);
            continue;
        }

        if(s.x < -50) samples.splice(i,1);
    }

    // Particles
    for(let i=particles.length-1; i>=0; i--) {
        let p = particles[i];
        p.x += p.vx; p.y += p.vy; p.life--;
        if(p.life <= 0) particles.splice(i,1);
    }

    // UI Updates
    document.getElementById('score-dist').innerText = Math.floor(scoreDist);
    document.getElementById('score-data').innerText = scoreData;
}

function draw() {
    // Sky
    let skyGrad = ctx.createLinearGradient(0, 0, 0, SCREEN_H);
    skyGrad.addColorStop(0, '#050510');
    skyGrad.addColorStop(1, '#2b1a05');
    ctx.fillStyle = skyGrad;
    ctx.fillRect(0, 0, SCREEN_W, SCREEN_H);

    // Stars
    ctx.fillStyle = '#fff';
    stars.forEach(s => ctx.fillRect(s.x, s.y, s.size, s.size));

    // REBEKAH (Planet) - High Fidelity
    let pX = SCREEN_W * 0.7;
    let pY = SCREEN_H * 0.25;
    ctx.save();
    ctx.translate(pX, pY);
    ctx.scale(0.6, 0.6); // Scale specifically for portrait width

    // Planet Body
    let pGrad = ctx.createLinearGradient(-50, -50, 50, 50);
    pGrad.addColorStop(0, '#4a0000'); pGrad.addColorStop(0.5, '#800000'); pGrad.addColorStop(1, '#200000');
    ctx.fillStyle = pGrad;
    ctx.beginPath(); ctx.arc(0, 0, 60, 0, Math.PI*2); ctx.fill();
    
    // Rings (Back)
    ctx.rotate(-0.3); ctx.scale(1, 0.3);
    ctx.beginPath(); ctx.arc(0, 0, 120, Math.PI, 0); 
    ctx.strokeStyle = 'rgba(97, 218, 251, 0.3)'; ctx.lineWidth = 15; ctx.stroke();
    ctx.beginPath(); ctx.arc(0, 0, 100, Math.PI, 0); 
    ctx.strokeStyle = '#61dafb'; ctx.lineWidth = 2; ctx.stroke();

    // Rings (Front)
    ctx.beginPath(); ctx.arc(0, 0, 120, 0, Math.PI); 
    ctx.strokeStyle = 'rgba(97, 218, 251, 0.3)'; ctx.lineWidth = 15; ctx.stroke();
    ctx.beginPath(); ctx.arc(0, 0, 100, 0, Math.PI); 
    ctx.strokeStyle = '#61dafb'; ctx.lineWidth = 2; ctx.stroke();
    ctx.restore();

    // Ground
    ctx.fillStyle = '#1a1205';
    ctx.fillRect(0, GROUND_Y, SCREEN_W, SCREEN_H - GROUND_Y);
    ctx.strokeStyle = '#d4a24e'; ctx.lineWidth = 2; 
    ctx.beginPath(); ctx.moveTo(0, GROUND_Y); ctx.lineTo(SCREEN_W, GROUND_Y); ctx.stroke();

    // Obstacles
    obstacles.forEach(o => {
        if(o.type === 'ROCK') {
            ctx.fillStyle = '#5c4d35';
            ctx.strokeStyle = '#8a7045'; ctx.lineWidth = 2;
            ctx.beginPath(); ctx.moveTo(o.x, GROUND_Y); 
            ctx.lineTo(o.x+o.w/2, GROUND_Y-o.h); ctx.lineTo(o.x+o.w, GROUND_Y); 
            ctx.fill(); ctx.stroke();
        } else {
            ctx.fillStyle = '#d4a24e';
            ctx.beginPath(); ctx.moveTo(o.x, GROUND_Y); 
            ctx.lineTo(o.x+10, GROUND_Y-40); ctx.lineTo(o.x+20, GROUND_Y); ctx.fill();
        }
    });

    // Samples
    samples.forEach(s => {
        ctx.save(); ctx.translate(s.x, s.y); ctx.rotate(s.rot);
        ctx.fillStyle = '#fff'; ctx.shadowColor = '#61dafb'; ctx.shadowBlur = 15;
        ctx.beginPath(); ctx.moveTo(0, -10); ctx.lineTo(10, 0); ctx.lineTo(0, 10); ctx.lineTo(-10, 0); ctx.fill();
        ctx.restore();
    });

    // Rover
    rover.draw();

    // Projectiles
    ctx.fillStyle = '#fff'; ctx.shadowColor = '#ff0'; ctx.shadowBlur = 10;
    projectiles.forEach(p => ctx.fillRect(p.x, p.y, 12, 4));
    ctx.shadowBlur = 0;

    // Particles
    particles.forEach(p => {
        ctx.fillStyle = p.color; ctx.fillRect(p.x, p.y, 3, 3);
    });
}

function loop() {
    if (gameState === 'PLAYING') {
        update();
        draw();
        requestAnimationFrame(loop);
    }
}

// --- STATE FUNCTIONS ---
function triggerStart() {
    console.log("Starting game...");
    
    // UI Transitions
    document.getElementById('start-screen').classList.add('hidden');
    document.getElementById('game-over-screen').classList.add('hidden');
    document.getElementById('hud').style.display = 'flex';
    document.getElementById('split-line').style.display = 'block';

    // Game Reset
    rover.reset();
    obstacles = []; samples = []; projectiles = []; particles = [];
    scoreDist = 0; scoreData = 0; frames = 0; gameSpeed = 6;

    resumeAudio();
    gameState = 'PLAYING';
    loop();
}

function gameOver() {
    gameState = 'GAMEOVER';
    document.getElementById('game-over-screen').classList.remove('hidden');
    document.getElementById('hud').style.display = 'none';
    document.getElementById('split-line').style.display = 'none';
    document.getElementById('final-dist').innerText = Math.floor(scoreDist);
    document.getElementById('final-data').innerText = scoreData;
}

// --- UNIVERSAL INPUT HANDLING ---

function handleInput(yPos) {
    if (gameState !== 'PLAYING') return;

    // Split Screen: Top 55% Jump, Bottom 45% Shoot
    const splitY = SCREEN_H * 0.55;
    
    if (yPos > splitY) {
        rover.shoot();
    } else {
        rover.jump();
    }
}

// 1. Mouse Down (Desktop/Testing)
window.addEventListener('mousedown', (e) => {
    // If we click on the UI layers, let the onclick handler do its job.
    // If UI is hidden, we handle game input.
    if (gameState === 'PLAYING') {
        handleInput(e.clientY);
    }
});

// 2. Touch Start (Mobile)
window.addEventListener('touchstart', (e) => {
    e.preventDefault(); // Stop scrolling/zooming
    if (gameState === 'PLAYING') {
        handleInput(e.touches[0].clientY);
    }
}, {passive: false});

// 3. Keyboard (Desktop Alt)
window.addEventListener('keydown', (e) => {
    if (e.code === 'Space' || e.code === 'ArrowUp') {
        if (gameState === 'START' || gameState === 'GAMEOVER') triggerStart();
        else rover.jump();
    }
    if (e.code === 'Enter' || e.code === 'KeyZ') {
        if (gameState === 'PLAYING') rover.shoot();
    }
});

// Init
resize(); // Call resize ONCE at the end, after everything is defined.
draw(); // Draw first frame background

</script>
</body>
</html>
