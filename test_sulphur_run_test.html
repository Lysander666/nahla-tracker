<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Sulphur Run - Vertical</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="mobile-web-app-capable" content="yes">
    
    <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=VT323&display=swap">

    <style>
        body {
            margin: 0;
            padding: 0;
            background-color: #050505;
            color: #eee;
            font-family: 'VT323', monospace;
            height: 100vh;
            width: 100vw;
            overflow: hidden;
            touch-action: none;
            user-select: none;
            -webkit-user-select: none;
        }

        #game-container {
            position: relative;
            width: 100%;
            height: 100%;
            background-color: #08060a;
            overflow: hidden;
        }

        canvas {
            display: block;
            width: 100%;
            height: 100%;
        }

        /* HUD: Moved to top center for portrait visibility */
        .hud {
            position: absolute;
            top: 5%;
            left: 50%;
            transform: translateX(-50%);
            width: 90%;
            display: flex;
            justify-content: space-between;
            font-size: 1.8rem;
            color: #d4a24e;
            text-shadow: 0 0 5px #000;
            z-index: 10;
            pointer-events: none;
        }

        /* UI Overlays */
        .ui-layer {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            display: flex; flex-direction: column;
            align-items: center; justify-content: center;
            background: rgba(0,0,0,0.85);
            z-index: 20;
            text-align: center;
        }
        
        .active-ui { pointer-events: auto; }
        .hidden-ui { display: none !important; pointer-events: none; }

        h1 { font-size: 3.5rem; color: #d4a24e; margin: 0 0 10px 0; line-height: 0.9; }
        p { font-size: 1.4rem; color: #ccc; margin: 10px 20px; }
        .blink { animation: blink 1s infinite; color: #fff; font-size: 1.8rem; margin-top: 30px; }
        @keyframes blink { 50% { opacity:0; } }

        /* SPLIT SCREEN CONTROLS VISUALIZER */
        /* We draw a faint line to show the player where the zones are */
        .control-divider {
            position: absolute;
            top: 60%; 
            left: 10%;
            width: 80%;
            height: 2px;
            background: linear-gradient(90deg, transparent, rgba(255,255,255,0.1), transparent);
            pointer-events: none;
        }
        
        .zone-label {
            position: absolute;
            font-size: 1.2rem;
            color: rgba(255,255,255,0.2);
            pointer-events: none;
            width: 100%;
            text-align: center;
        }
    </style>
</head>
<body>

    <div id="game-container">
        <canvas id="gameCanvas"></canvas>
        
        <div class="hud" id="hud" style="display:none;">
            <span>DIST: <span id="score-dist" style="color:#fff">0</span></span>
            <span>DATA: <span id="score-data" style="color:#61dafb">0</span></span>
        </div>

        <div class="control-divider" id="divider" style="display:none;"></div>
        <div class="zone-label" id="lbl-jump" style="top: 40%; display:none;">( TAP TOP TO JUMP )</div>
        <div class="zone-label" id="lbl-shoot" style="top: 80%; display:none;">( TAP BOTTOM TO SHOOT )</div>

        <div class="ui-layer active-ui" id="start-screen">
            <h1>SULPHUR<br>RUN</h1>
            <p style="color:#61dafb; letter-spacing: 2px;">VERTICAL PROTOCOL</p>
            <div style="margin: 20px 0; border: 1px solid #333; padding: 10px; width: 80%;">
                <span style="color:#d4a24e">TOP ZONE:</span> JUMP<br>
                <span style="color:#ff4444">BOTTOM ZONE:</span> SHOOT
            </div>
            <p class="blink">[ TAP TO START ]</p>
        </div>

        <div class="ui-layer hidden-ui" id="game-over-screen">
            <h1 style="color:#ff4444">CRITICAL<br>FAILURE</h1>
            <p>DISTANCE: <span id="final-dist">0</span>m</p>
            <p>DATA: <span id="final-data" style="color:#61dafb; font-size: 2rem;">0</span></p>
            <p class="blink">[ TAP TO REBOOT ]</p>
        </div>
    </div>

    <audio id="bgm" loop preload="auto" src="nahla_theme.mp3"></audio>

<script>
/** SULPHUR RUN - TRUE PORTRAIT EDITION **/

const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
const bgm = document.getElementById('bgm');

// --- RESIZE LOGIC ---
// We set the canvas to match the screen exactly
function resize() {
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
    // Recalculate Ground based on screen height
    // Ground is 15% from bottom
    GROUND_Y = canvas.height * 0.85; 
}
window.addEventListener('resize', resize);

// --- AUDIO ENGINE ---
const AudioContext = window.AudioContext || window.webkitAudioContext;
const actx = new AudioContext();

function playSound(type) {
    if(actx.state === 'suspended') actx.resume();
    const osc = actx.createOscillator();
    const gain = actx.createGain();
    osc.connect(gain); gain.connect(actx.destination);
    
    const now = actx.currentTime;
    if(type === 'jump') {
        osc.frequency.setValueAtTime(150, now);
        osc.frequency.linearRampToValueAtTime(300, now + 0.15);
        gain.gain.setValueAtTime(0.1, now);
        gain.gain.exponentialRampToValueAtTime(0.01, now + 0.2);
        osc.start(now); osc.stop(now + 0.2);
    } else if(type === 'shoot') {
        osc.type = 'square';
        osc.frequency.setValueAtTime(600, now);
        osc.frequency.exponentialRampToValueAtTime(100, now + 0.1);
        gain.gain.setValueAtTime(0.05, now);
        gain.gain.exponentialRampToValueAtTime(0.01, now + 0.1);
        osc.start(now); osc.stop(now + 0.1);
    } else if(type === 'hit') {
        osc.type = 'sawtooth';
        osc.frequency.setValueAtTime(100, now);
        osc.frequency.linearRampToValueAtTime(20, now + 0.3);
        gain.gain.setValueAtTime(0.2, now);
        gain.gain.linearRampToValueAtTime(0, now + 0.3);
        osc.start(now); osc.stop(now + 0.3);
    } else if(type === 'collect') {
        osc.type = 'sine';
        osc.frequency.setValueAtTime(1200, now);
        gain.gain.setValueAtTime(0.1, now);
        gain.gain.exponentialRampToValueAtTime(0.01, now + 0.1);
        osc.start(now); osc.stop(now + 0.1);
    }
}

// --- GAME VARS ---
let GROUND_Y = 500; // Will be overwritten by resize()
let gameState = 'START';
let frames = 0;
let gameSpeed = 5; // Slower start for narrow screens
let score = 0;
let dist = 0;

let rover = { x: 30, y: 0, w: 40, h: 20, dy: 0, grounded: false, jumps: 0 };
let obstacles = [];
let projectiles = [];
let stars = [];
let particles = [];

// Initialize Size
resize();

function initGame() {
    gameState = 'PLAYING';
    score = 0;
    dist = 0;
    gameSpeed = 6;
    frames = 0;
    obstacles = [];
    projectiles = [];
    particles = [];
    rover.y = GROUND_Y - 20;
    rover.dy = 0;
    
    // UI Updates
    document.getElementById('start-screen').classList.add('hidden-ui');
    document.getElementById('start-screen').classList.remove('active-ui');
    document.getElementById('game-over-screen').classList.add('hidden-ui');
    document.getElementById('game-over-screen').classList.remove('active-ui');
    
    document.getElementById('hud').style.display = 'flex';
    document.getElementById('divider').style.display = 'block';
    document.getElementById('lbl-jump').style.display = 'block';
    document.getElementById('lbl-shoot').style.display = 'block';

    // Start Music
    if(bgm && bgm.paused) bgm.play().catch(e => console.log(e));
    if(actx.state === 'suspended') actx.resume();
    
    // Create Background Stars
    stars = [];
    for(let i=0; i<80; i++) {
        stars.push({
            x: Math.random() * canvas.width,
            y: Math.random() * GROUND_Y,
            size: Math.random() * 2,
            speed: Math.random() * 0.5
        });
    }
}

function spawnObstacle() {
    let type = Math.random() > 0.6 ? 'SPIKE' : 'ROCK';
    if(Math.random() > 0.9) type = 'DRONE'; // Floating enemy
    
    obstacles.push({
        x: canvas.width + 50,
        y: type === 'DRONE' ? GROUND_Y - 50 - Math.random()*40 : GROUND_Y,
        w: 30, h: 30,
        type: type,
        hp: 1
    });
}

function update() {
    if(gameState !== 'PLAYING') return;

    frames++;
    dist += 0.1;
    gameSpeed += 0.001; // Slow acceleration

    // Difficulty
    if(frames % 100 === 0 && Math.random() > 0.2) spawnObstacle();

    // Rover Physics
    rover.dy += 0.6; // Gravity
    rover.y += rover.dy;

    if(rover.y > GROUND_Y - 20) {
        rover.y = GROUND_Y - 20;
        rover.dy = 0;
        rover.grounded = true;
        rover.jumps = 0;
    } else {
        rover.grounded = false;
    }

    // Projectiles
    for(let i=projectiles.length-1; i>=0; i--) {
        let p = projectiles[i];
        p.x += p.vx;
        if(p.x > canvas.width) projectiles.splice(i,1);
    }

    // Obstacles
    for(let i=obstacles.length-1; i>=0; i--) {
        let o = obstacles[i];
        o.x -= gameSpeed;

        // Collision Check
        let hit = false;
        // Simple AABB
        if (rover.x < o.x + o.w && rover.x + rover.w > o.x &&
            rover.y < o.y && rover.y + rover.h > o.y - o.h) {
            
            // Special case for ground obstacles vs jumping
            if(o.type !== 'DRONE' && rover.y + rover.h <= o.y - o.h + 10) {
                // Safe (jumping over)
            } else {
                hit = true;
            }
            
            // Re-check strict collision for simple shapes
            if(o.type === 'ROCK' || o.type === 'SPIKE') {
                // We simplify collision: if rover bottom is below obstacle top
                 if(rover.y + rover.h > o.y - o.h + 5) hit = true;
            }
            if(o.type === 'DRONE') {
                if(rover.y < o.y + 10 && rover.y + rover.h > o.y - 10) hit = true;
            }
        }

        if(hit) {
            playSound('hit');
            gameOver();
        }

        // Projectile Hit
        for(let k=projectiles.length-1; k>=0; k--) {
            let p = projectiles[k];
            // Hitbox logic
            let pHit = false;
            if(o.type === 'DRONE') {
                if(p.x > o.x && p.x < o.x+30 && p.y > o.y-15 && p.y < o.y+15) pHit = true;
            } else {
                if(p.x > o.x && p.x < o.x+30 && p.y > o.y-30) pHit = true;
            }

            if(pHit) {
                o.hp--;
                projectiles.splice(k,1);
                if(o.hp <= 0) {
                    score += 50;
                    playSound('collect');
                    // Explosion particles
                    for(let j=0; j<5; j++) particles.push({x: o.x, y: o.y-15, vx: Math.random()*4-2, vy: Math.random()*-4, life: 20});
                    obstacles.splice(i,1);
                }
                break;
            }
        }
        
        if(o.x < -50 && obstacles[i]) obstacles.splice(i,1);
    }

    // Stars
    stars.forEach(s => {
        s.x -= gameSpeed * s.speed;
        if(s.x < 0) s.x = canvas.width;
    });

    // Particles
    for(let i=particles.length-1; i>=0; i--) {
        let p = particles[i];
        p.x += p.vx; p.y += p.vy; p.life--;
        if(p.life <= 0) particles.splice(i,1);
    }

    // UI
    document.getElementById('score-dist').innerText = Math.floor(dist);
    document.getElementById('score-data').innerText = score;
}

function draw() {
    // Clear & Sky
    const grad = ctx.createLinearGradient(0, 0, 0, canvas.height);
    grad.addColorStop(0, '#050510');
    grad.addColorStop(1, '#2a1a1a');
    ctx.fillStyle = grad;
    ctx.fillRect(0, 0, canvas.width, canvas.height);

    // Planet (Hope) - Big background element
    ctx.fillStyle = '#000';
    ctx.beginPath(); ctx.arc(canvas.width * 0.7, 150, 40, 0, Math.PI*2); ctx.fill();
    ctx.strokeStyle = '#61dafb';
    ctx.lineWidth = 2;
    ctx.beginPath(); ctx.arc(canvas.width * 0.7, 150, 40, 0, Math.PI*2); ctx.stroke();

    // Stars
    ctx.fillStyle = '#fff';
    stars.forEach(s => ctx.fillRect(s.x, s.y, s.size, s.size));

    // Ground
    const groundGrad = ctx.createLinearGradient(0, GROUND_Y, 0, canvas.height);
    groundGrad.addColorStop(0, '#3a2a1a');
    groundGrad.addColorStop(1, '#110a05');
    ctx.fillStyle = groundGrad;
    ctx.fillRect(0, GROUND_Y, canvas.width, canvas.height - GROUND_Y);
    
    // Grid line on ground top
    ctx.strokeStyle = '#d4a24e';
    ctx.lineWidth = 3;
    ctx.beginPath(); ctx.moveTo(0, GROUND_Y); ctx.lineTo(canvas.width, GROUND_Y); ctx.stroke();

    // Rover
    ctx.save();
    ctx.translate(rover.x + rover.w/2, rover.y + rover.h/2);
    // Dynamic Tilt
    ctx.rotate(rover.dy * 0.05);
    // Body
    ctx.fillStyle = '#d4a24e';
    ctx.fillRect(-20, -10, 40, 16);
    // Cockpit
    ctx.fillStyle = '#61dafb';
    ctx.shadowColor = '#61dafb'; ctx.shadowBlur = 10;
    ctx.fillRect(0, -14, 12, 8);
    ctx.shadowBlur = 0;
    // Wheels
    ctx.fillStyle = '#111';
    const bounce = rover.grounded ? Math.sin(frames*0.8)*1.5 : 0;
    ctx.beginPath(); ctx.arc(-15, 8+bounce, 7, 0, 6.28); ctx.fill();
    ctx.beginPath(); ctx.arc(15, 8-bounce, 7, 0, 6.28); ctx.fill();
    ctx.restore();

    // Obstacles
    obstacles.forEach(o => {
        if(o.type === 'ROCK') {
            ctx.fillStyle = '#654';
            ctx.beginPath(); ctx.moveTo(o.x, GROUND_Y); ctx.lineTo(o.x+15, GROUND_Y-o.h); ctx.lineTo(o.x+30, GROUND_Y); ctx.fill();
        } else if (o.type === 'SPIKE') {
            ctx.fillStyle = '#d4a24e';
            ctx.beginPath(); ctx.moveTo(o.x, GROUND_Y); ctx.lineTo(o.x+10, GROUND_Y-35); ctx.lineTo(o.x+20, GROUND_Y); ctx.fill();
        } else if (o.type === 'DRONE') {
            ctx.fillStyle = '#ff4444';
            ctx.beginPath(); ctx.arc(o.x+15, o.y, 10, 0, 6.28); ctx.fill();
            ctx.fillStyle = '#fff'; ctx.fillRect(o.x+10, o.y-2, 10, 4); // eye
        }
    });

    // Projectiles
    ctx.fillStyle = '#ff0';
    ctx.shadowColor = '#ff0'; ctx.shadowBlur = 5;
    projectiles.forEach(p => ctx.fillRect(p.x, p.y, 10, 4));
    ctx.shadowBlur = 0;

    // Particles
    ctx.fillStyle = '#d4a24e';
    particles.forEach(p => ctx.fillRect(p.x, p.y, 3, 3));
}

function loop() {
    requestAnimationFrame(loop);
    update();
    draw();
}

function gameOver() {
    gameState = 'GAMEOVER';
    document.getElementById('final-dist').innerText = Math.floor(dist);
    document.getElementById('final-data').innerText = score;
    document.getElementById('game-over-screen').classList.remove('hidden-ui');
    document.getElementById('game-over-screen').classList.add('active-ui');
    document.getElementById('hud').style.display = 'none';
    document.getElementById('divider').style.display = 'none';
    document.getElementById('lbl-jump').style.display = 'none';
    document.getElementById('lbl-shoot').style.display = 'none';
}

// --- TOUCH HANDLING ---
window.addEventListener('touchstart', e => {
    e.preventDefault();
    const t = e.touches[0];
    const clickY = t.clientY;
    
    if(gameState === 'START' || gameState === 'GAMEOVER') {
        initGame();
        return;
    }

    // CONTROL SCHEME:
    // Top 60% of screen = JUMP
    // Bottom 40% of screen = SHOOT
    // This allows thumbs to rest naturally at bottom for shooting
    if (clickY < window.innerHeight * 0.6) {
        if(rover.jumps < 2) { 
            rover.dy = -10; 
            rover.jumps++; 
            rover.grounded = false; 
            playSound('jump');
        }
    } else {
        // Cooldown check for shooting
        rover.shootCooldown = rover.shootCooldown || 0;
        if(frames - rover.shootCooldown > 10) {
            projectiles.push({x: rover.x + 30, y: rover.y + 10, vx: 12});
            playSound('shoot');
            rover.shootCooldown = frames;
        }
    }
}, {passive: false});

// Loop
loop();

</script>
</body>
</html>
